#include <pch.hpp>
#include <Scene.hpp>
#include <Window.hpp>
#include <Actor/AActor.hpp>
#include <Object/Background.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// *structors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::rts::Scene::Scene(
    ::rts::Window& window
)
    : m_window(window)
{
    m_uis.push_back(::std::make_shared<::rts::object::Background>("background.png"));
}

///////////////////////////////////////////////////////////////////////////
::rts::Scene::~Scene() = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Actions
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::rts::Scene::update()
{
    m_window.handleEvents(*this);
    ::std::ranges::for_each(m_actors, [this](auto& actor){ actor->update(m_clock.getElapsed(), *actor); });
}

///////////////////////////////////////////////////////////////////////////
void ::rts::Scene::draw() const
{
    m_window.clear();
    ::std::ranges::for_each(m_actors, [this](auto& actor){ actor->draw(m_window); });
    ::std::ranges::for_each(m_uis, [this](auto& actor){ actor->draw(m_window); });
    m_window.display();
}

///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] auto ::rts::Scene::isOver() const
    -> bool
{
    return !m_window.isOpen() || m_isOver;
}

///////////////////////////////////////////////////////////////////////////
auto ::rts::Scene::handleEvent(
    sf::Event& event
) -> bool
{
    switch (event.type) {
    case ::sf::Event::Closed: m_window.close(); return false;
    case ::sf::Event::KeyPressed:
        switch (event.key.code) {
        case sf::Keyboard::Key::Escape: m_window.close(); return false;
        default: return true;
        }
    default: return true;
    }
}
